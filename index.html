<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Physics JSON Editor</title>
  <script src="https://cdn.jsdelivr.net/npm/vue@2"></script>
</head>

<body>
  <style>
    table,
    th,
    td {
      border: 1px solid black;
      border-collapse: collapse;
    }

    table.no-border,
    table.no-border th,
    table.no-border td {
      border: none;
    }

    th,
    td {
      padding: 5px 10px;
    }

    .RowSwapWaning {
      background-color: hotpink;
    }
  </style>
  <div id="app">
    <div>
      You can send Feedback to me (UFOnian) at <a href="https://github.com/UFOnian/.physics3.json-Editor">here</a>.
    </div>
    <div v-show="!isEditing">
      <!-- File Selector -->
      <table>
        <tr>
          <th>title</th>
          <td>Target File</td>
          <td>Import File</td>
        </tr>
        <tr>
          <th>File Selector</th>
          <td><input type="file" name="objFile" id="objFile" /></td>
          <td>
            <input type="file" name="srcFile" id="srcFile" /><br />
            <input type="button" value="clear" @click="clearSrcFile" />
          </td>
        </tr>
        <tr>
          <th>Errors<br />(when exists)</th>
          <td style="color: red;">
            <p v-for="v in objFileErrors">{{v}}</p>
          </td>
          <td style="color: red;">
            <p v-for="v in srcFileErrors">{{v}}</p>
          </td>
        </tr>
      </table>
      <div>
        <p style="color: red;" v-for="v in befEditErrors">{{v}}</p>
        <input type="button" value="Start Editing" @click="editStart" :disabled="!canStartEditing" />
      </div>
    </div>
    <div v-show="isEditing">
      <!-- Source Files Display -->
      <table>
        <tr>
          <th>title</th>
          <td>Target File</td>
          <td>Import File</td>
        </tr>
        <tr>
          <th>File</th>
          <td>{{selectedTargetFile}}</td>
          <td>{{selectedImportFile}}</td>
        </tr>
      </table>
      <div>
        <input type="button" value="Reselect Files" @click="reselectFiles" />
      </div>
    </div>
    <div v-show="isEditing">
      <!-- Main Editor -->
      <table>
        <tr>
          <th>Sort</th>
          <th>Physics Dictionary Name</th>
          <th colspan="2">Exists in Target File</th>
          <th colspan="2">Exists in Import File</th>
        </tr>
        <tr v-for="(v,i) in editTemp" :key="v.name" :data-key="v.name">
          <td style="padding: 0;">
            <table class="no-border" style="padding: 0;">
              <tr style="padding: 0;">
                <td style="padding: 5px 0 5px 5px;">
                  <input type="button" value="▲" style="display: block" tabindex="-1" :disabled="!i" @click="swapper(i-1,i)" />
                  <input type="button" value="▼" style="display: block" tabindex="-1" :disabled="!(editTemp.length-i-1)"
                    @click="swapper(i,i+1)" />
                </td>
                <td style="padding: 0 5px 0 2px;">
                  <input type="text" size="1" inputmode="numeric" pattern="\d|[1-9]\d*" name="editTblSorter" class="sortNum" min="0"
                    :max="editTemp.length-1" step="1" :value="i" @keydown.up.prevent="chgSortNum(i, null, i-1,v.name)"
                    @keydown.down.prevent="chgSortNum(i, null, i+1,v.name)" @keydown.subtract.prevent
                    @change.prevent="chgSortNum(i, $event, 0, v.name)">
                </td>
              </tr>
            </table>
          </td>
          <td :style="v.removeData ? 'background-color: darkgray;' : v.importData ? 'background-color: palegreen;' : ''">
            {{v.name}}
          </td>
          <!-- Exists in Target File -->
          <td style="width: 0;" :class="destSwapped(i)">
            {{v.hasDestData ? v.destIndex : ""}}
          </td>
          <td :style="v.removeData ? 'background-color: darkgray;' : ''">
            {{v.hasDestData ? 'YES' : 'No'}}
            <span v-show="v.hasDestData">
              <input type="checkbox" v-model="v.removeData" />Remove
            </span>
          </td>
          <!-- Exists in Import File -->
          <td style="width: 0;" :class="tempSwapped(i)">
            {{v.hasTmpData ? v.tmpIndex : ""}}
          </td>
          <td :style="v.removeData ? 'background-color: darkgray;' : v.importData ? 'background-color: palegreen;' : ''">
            {{v.hasTmpData ? 'YES' : 'No'}}
            <span v-show="v.hasTmpData">
              <input type="checkbox" v-model="v.importData" :disabled="v.removeData" />Import
            </span>
          </td>
        </tr>
      </table>
      <input type="button" value="Export" @click="exportJSON" />
      <a style="display: none;" id="downloader" download="edited.physics3.json"></a>
      <p>
        <b>Added Output Parameter</b><br />
        <span v-for="v in addedOutputParams">{{v}}<br /></span>
      </p>
    </div>
  </div>
  <script>
    const styles = {
      CRowSwapWaning: ['RowSwapWaning'],
    };
    const app = new Vue({
      el: "#app",
      data: {
        objFileErrors: [],
        srcFileErrors: [],
        befEditErrors: [],
        selectedTargetFile: "",
        selectedImportFile: "",
        canStartEditing: false,
        isEditing: false,
        fcDest: null,
        objFileContent: null,
        fcTemp: null,
        srcFileContent: null,
        editTemp: [
          {
            name: "physicsDictionaryName",
            hasDestData: false,
            destIndex: -1,
            hasTmpData: false,
            tmpIndex: -1,
            removeData: false,
            importData: false,
            sortSelect: false,
          },
        ],
      },
      methods: {
        newEditTempRow: function (init) {
          const tmp = {
            name: "physicsDictionaryName",
            hasDestData: false,
            destIndex: -1,
            hasTmpData: false,
            tmpIndex: -1,
            removeData: false,
            importData: false,
            sortSelect: false,
          };
          Object.keys(tmp).forEach(v => {
            if (init.hasOwnProperty(v)) {
              tmp[v] = init[v];
            }
          });
          return tmp;
        },
        initEditTemp: function () {
          let arr = this.fcDest.Meta.PhysicsDictionary.map((v, i) => this.newEditTempRow({
            name: v.Name,
            hasDestData: true,
            destIndex: i,
          }));
          const tmp = (this.fcTemp?.Meta?.PhysicsDictionary || []).map((v) => v.Name);
          arr = arr.concat(
            tmp
              .map((v, i) => this.newEditTempRow({
                name: v,
                hasTmpData: true,
                tmpIndex: i,
              }))
              .filter((v) => !arr.some((e) => e.name == v.name))
          );
          arr
            .filter((v) => v.hasDestData && tmp.includes(v.name))
            .forEach((v) => {
              if (!v.hasDestData) return;
              tmp.forEach((e, i) => {
                if (v.hasTmpData) return;
                if (e == v.name) {
                  v.hasTmpData = true;
                  v.tmpIndex = i;
                }
              });
            });
          this.editTemp = arr;
        },
        swapper(i, j) {
          if (i == j) return;
          const temp = (this.editTemp.splice(i, 1, this.editTemp[j]))[0];
          this.editTemp.splice(j, 1, temp);
        },
        chgSortNum: function (i, event, j, name) {
          if (i < 0 || this.editTemp.length - 1 < i) return this.restoreFocus(name);;
          if (event) {
            j = event.target.value;
          }
          if (j < 0 || this.editTemp.length - 1 < j) return this.restoreFocus(name);;
          this.swapper(i, j);
          this.restoreFocus(name);
        },
        restoreFocus: function (name) {
          this.$nextTick(() => {
            document.querySelector("[data-key=\"" + name + "\"] [name=editTblSorter]").focus();
          });
        },
        exportJSON: function () {
          const newFc = JSON.parse(JSON.stringify(this.fcDest));
          const newPhysicsSettings = [];
          const newPhysicsDictionary = [];

          this.editTemp.forEach((v) => {
            if (v.removeData) return;
            if (v.hasDestData) {
              if (v.importData) {
                newPhysicsSettings.push(this.fcTemp.PhysicsSettings[v.tmpIndex]);
                newPhysicsDictionary.push(this.fcTemp.Meta.PhysicsDictionary[v.tmpIndex]);
                return;
              } else {
                newPhysicsSettings.push(this.fcDest.PhysicsSettings[v.destIndex]);
                newPhysicsDictionary.push(this.fcDest.Meta.PhysicsDictionary[v.destIndex]);
                return;
              }
            }
            if (v.importData) {
              newPhysicsSettings.push(this.fcTemp.PhysicsSettings[v.tmpIndex]);
              newPhysicsDictionary.push(this.fcTemp.Meta.PhysicsDictionary[v.tmpIndex]);
            }
          });

          newFc.PhysicsSettings = newPhysicsSettings;
          newFc.Meta.PhysicsDictionary = newPhysicsDictionary;
          newFc.Meta.PhysicsDictionary.forEach((v, i) => {
            const id = "PhysicsSetting" + (i + 1);
            v.Id = id;
            newFc.PhysicsSettings[i].Id = id;
          });
          newFc.Meta.PhysicsSettingCount = newPhysicsSettings.length;
          const counts = newPhysicsSettings.reduce(
            (p, v) => [
              p[0] + v.Input.length,
              p[1] + v.Output.length,
              p[2] + v.Vertices.length
            ], [0, 0, 0]
          );
          newFc.Meta.TotalInputCount = counts[0];
          newFc.Meta.TotalOutputCount = counts[1];
          newFc.Meta.VertexCount = counts[2];

          const jsonStr = JSON.stringify(newFc, null, 2);
          const blob = new Blob([jsonStr], { type: "application/json;charset=utf-8" });
          const url = URL.createObjectURL(blob);
          const a = document.getElementById("downloader");
          a.href = url;
          a.click();
          URL.revokeObjectURL(url);
        },
        clearSrcFile: function () {
          this.selectedImportFile = "";
          this.srcFileContent = null;
          this.srcFileErrors.splice(0);
          srcFile.value = "";
          checkBeforeEditError();
        },
        editStart: function () {
          if (this.isEditing || !this.canStartEditing) {
            return;
          }
          this.fcDest = JSON.parse(JSON.stringify(this.objFileContent));
          this.fcTemp = this.srcFileContent
            ? JSON.parse(JSON.stringify(this.srcFileContent))
            : null;
          this.isEditing = true;
          this.initEditTemp();
        },
        reselectFiles: function () {
          if ("reselect" != prompt("Your Edits will be lost.\nIf you are sure type \"reselect\" into the following box and push OK.", "deny")) {
            return;
          }
          this.isEditing = false;
        },
        destSwapped: function (idx) {
          const curDestIndex = this.editTemp[idx].destIndex;
          return (curDestIndex >= 0
            && this.editTemp.slice(0, idx).some(e => e.destIndex >= curDestIndex)
            ? styles.CRowSwapWaning
            : '');
        },
        tempSwapped: function (idx) {
          const curTmpIndex = this.editTemp[idx].tmpIndex;
          return (curTmpIndex >= 0
            && this.editTemp.slice(0, idx).some(e => e.tmpIndex >= curTmpIndex)
            ? styles.CRowSwapWaning
            : '');
        },
      },
      computed: {
        destParams: function () {
          const src = this.fcDest;
          if (!src) return [];
          if (!src || !src?.PhysicsSettings?.length) return [];
          return this.editTemp.filter(v => v.hasDestData && !v.removeData).reduce(
            (p1, v1) => p1.concat(
              this.fcDest.PhysicsSettings[v1.destIndex].Output
                .filter(v2 => v2.Destination.Target == "Parameter").map(v2 => v2.Destination.Id)
            ).concat(
              this.fcDest.PhysicsSettings[v1.destIndex].Input
                .filter(v2 => v2.Source.Target == "Parameter").map(v2 => v2.Source.Id)
            )
            , []);
        },
        importOutputParams: function () {
          if (!this.fcTemp) return [];
          return this.editTemp.filter(v => v.hasTmpData && !v.removeData && v.importData).reduce(
            (p1, v1) => p1.concat(
              this.fcTemp.PhysicsSettings[v1.tmpIndex].Output
                .filter(v2 => v2.Destination.Target == "Parameter").map(v2 => v2.Destination.Id)
            )
            , []);
        },
        addedOutputParams: function () {
          if (!this.fcTemp) return [];
          if (!this.importOutputParams.length) return [];
          return this.importOutputParams.filter(v => !this.destParams.includes(v));
        },
        importInputParams: function () {
          if (!this.fcTemp) return [];
          return this.editTemp.filter(v => v.hasTmpData && !v.removeData && v.importData).reduce(
            (p1, v1) => p1.concat(
              this.fcTemp.PhysicsSettings[v1.tmpIndex].Input
                .filter(v2 => v2.Source.Target == "Parameter").map(v2 => v2.Source.Id)
            )
            , []);
        },
        addedInputParams: function () {
          if (!this.fcTemp) return [];
          if (!this.importInputParams.length) return [];
          return this.importInputParams.filter(v => !this.destParams.includes(v));
        },
      },
    });

    const objFile = document.getElementById("objFile");
    const srcFile = document.getElementById("srcFile");

    const reader1 = new FileReader();
    reader1.onload = function (e) {
      try {
        let text = e.target.result;
        text = JSON.parse(text);
        app.selectedTargetFile = objFile.files[0].name;
        app.objFileContent = text;
      } catch (err) {
        app.objFileErrors.push("Failed to read file as JSON: " + err.message);
      }
      checkBeforeEditError();
    };
    reader1.onerror = function () {
      app.objFileErrors.push("Failed to read file");
    };
    const reader2 = new FileReader();
    reader2.onload = function (e) {
      try {
        let text = e.target.result;
        text = JSON.parse(text);
        app.selectedImportFile = srcFile.files[0].name;
        app.srcFileContent = text;
      } catch (err) {
        app.srcFileErrors.push("Failed to read file as JSON: " + err.message);
      }
      checkBeforeEditError();
    };
    reader2.onerror = function () {
      app.srcFileErrors.push("Failed to read file");
    };
    function checkBeforeEditError() {
      app.canStartEditing = false;
      app.befEditErrors.splice(0);
      if (!app.objFileContent) {
        app.befEditErrors.push("Target File is Empty.");
      } else if (app.objFileContent.Version != 3) {
        app.befEditErrors.push("Target File’s version is not supported.");
      } else if (!isValidPhysicsJSON(app.objFileContent, "Target")) {
        app.befEditErrors.push("Target File is not valid as .physics3.json");
      }
      if (!app.srcFileContent) {
        // app.befEditErrors.push("Import File is Empty.");
      } else if (app.srcFileContent.Version != 3) {
        app.befEditErrors.push("Import File’s version is not supported.");
      } else if (!isValidPhysicsJSON(app.srcFileContent, "Import")) {
        app.befEditErrors.push("Import File is not valid as .physics3.json");
      }
      app.canStartEditing = app.befEditErrors.length == 0;
    }

    objFile.onchange = function () {
      const file = objFile.files[0];
      app.selectedTargetFile = "";
      app.objFileContent = null;
      app.objFileErrors.splice(0);
      if (!file) {
        app.objFileErrors.push("Target File is Empty");
        checkBeforeEditError();
        return;
      }
      reader1.readAsText(file, "utf-8");
    };
    srcFile.onchange = function () {
      const file = srcFile.files[0];
      app.selectedImportFile = "";
      app.srcFileContent = null;
      app.srcFileErrors.splice(0);
      if (!file) {
        app.srcFileErrors.push("Import File is Empty");
        checkBeforeEditError();
        return;
      }
      reader2.readAsText(file, "utf-8");
    };

    function isValidPhysicsJSON(obj, name) {
      if (!obj || !obj?.PhysicsSettings?.length || !obj?.Meta?.PhysicsDictionary?.length) {
        app.befEditErrors.push(`${name} File is missing Meta.PhysicsDictionary or PhysicsSettings`);
        return false;
      }
      if (obj.PhysicsSettings.length < obj.Meta.PhysicsDictionary.length) {
        app.befEditErrors.push(`${name} File contains more entries in Meta.PhysicsDictionary than in PhysicsSettings`);
        return false;
      }
      if (obj.Meta.PhysicsDictionary.some((pd, i) => pd.Id !== obj.PhysicsSettings[i].Id)) {
        app.befEditErrors.push(`${name} File has mismatched Ids between Meta.PhysicsDictionary and PhysicsSettings`);
        return false;
      }
      const names = obj.Meta.PhysicsDictionary.map(v => v.Name);
      if (new Set(names).size !== names.length) {
        app.befEditErrors.push(`${name} File contains duplicate Names in Meta.PhysicsDictionary`);
        return false;
      }
      return true;
    }

  </script>
</body>

</html>
