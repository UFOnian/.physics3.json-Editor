<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Physics JSON Editor</title>
  <!-- <script src="vue.js"></script> -->
  <script src="https://cdn.jsdelivr.net/npm/vue@2.7.11"></script>
</head>

<style>
  table,
  th,
  td {
    border: 1px solid black;
    border-collapse: collapse;
  }

  table.no-border,
  table.no-border th,
  table.no-border td {
    border: none;
  }

  table.spaced th,
  table.spaced td {
    padding: 5px 10px;
  }

  th,
  td {
    padding: 0px 5px;
  }


  .fromtarget {
    background-color: powderblue;
  }

  .fromimport {
    background-color: palegreen;
  }

  .removed {
    background-color: lightgray;
  }

  input[type=checkbox].big {
    margin: 0px;
    -ms-transform: scale(1.5, 1.5);
    -webkit-transform: scale(1.5, 1.5);
    transform: scale(1.5, 1.5);
  }

  .RowSwapWarning {
    background-color: hotpink;
  }

  input[type=radio]:not(:checked)+.toggle {
    border: solid 1px #777;
    color: #333;
    margin: 1px;
    box-shadow: 0 1px 2px rgba(0, 0, 0, .4);
  }

  input[type=radio]:not(:checked):not(:disabled):hover+.toggle {
    box-shadow: -1.5px 1.5px 1px #c2c;
  }

  input[type=radio]:checked+.toggle {
    border: solid 1px #000;
    color: #000;
    box-shadow:
      inset 0 2px 4px rgba(0, 0, 0, .6);
  }

  input[type=radio]+.toggle {
    border-radius: 4px;
    cursor: pointer;
    user-select: none;
    transition:
      background-color 0.15s,
      box-shadow 0.15s,
      transform 0.05s;
  }

  input[type=radio]:disabled+.toggle {
    cursor: unset;
    background-color: lightgray;
    box-shadow: none;
    border-color: #aaa;
    color: #aaa;
  }

  .toggle {
    white-space: wrap;
    padding: 1px 6px;
    font-size: smaller;
  }

  input[type=radio]:has(+.toggle) {
    display: none;
  }

  .controller-pane {
    text-align: center;
    padding: 4px 0 0 0;
  }

  .controller-pane .control-button {
    width: 30px;
    height: 30px;
    padding: 1px;
    margin: 5px 0 0 0;
    display: inline-block;
    text-align: center;
    font-size: medium;
    font-weight: bolder;
  }
</style>

<body>
  <div id="app">
    <div>
      You can send Feedback to me (UFOnian) at <a href="https://github.com/UFOnian/.physics3.json-Editor">here</a>.
    </div>
    <div v-show="!isEditing">
      <!-- File Selector -->
      <table class="spaced">
        <tr>
          <th>title</th>
          <td class="fromtarget">Target File</td>
          <td class="fromimport">Import File</td>
        </tr>
        <tr>
          <th>File Selector</th>
          <td><input type="file" name="objFile" id="objFile" /></td>
          <td>
            <input type="file" name="srcFile" id="srcFile" /><br />
            <input type="button" value="clear" @click="clearSrcFile" />
          </td>
        </tr>
        <tr>
          <th>Errors<br />(when exists)</th>
          <td style="color: red;">
            <p v-for="v in objFileErrors">{{v}}</p>
          </td>
          <td style="color: red;">
            <p v-for="v in srcFileErrors">{{v}}</p>
          </td>
        </tr>
      </table>
      <div>
        <p style="color: red;" v-for="v in befEditErrors">{{v}}</p>
        <input type="button" value="Start Editing" @click="editStart" :disabled="!canStartEditing" />
      </div>
    </div>
    <div v-show="isEditing">
      <!-- Source Files Display -->
      <table>
        <tr>
          <th>title</th>
          <td>Target File</td>
          <td>Import File</td>
        </tr>
        <tr>
          <th>File</th>
          <td>{{selectedTargetFile}}</td>
          <td>{{selectedImportFile}}</td>
        </tr>
      </table>
      <div>
        <input type="button" value="Reselect Files" @click="reselectFiles" />
      </div>
    </div>
    <div v-show="isEditing||isDebug">
      <div style="display: flex; align-items: start; height: 300px;" style="border: solid 1px;">
        <div style="display: flex;flex-direction: column; width: 49%; height: 100%;" style="border: solid 1px;">
          <!-- SelectionPane -->
          <div style="padding: 4px 0 4px 15px; height: 24px;">
            <div style="display: inline-block; height: 100%;">
              <span style="font-size: smaller;">select source:</span>
              <input type="radio" name="srcSelect" id="d-src1" value="1" v-model="displist">
              <label for="d-src1" class="toggle fromtarget">Original</label>
              <input type="radio" name="srcSelect" id="d-src2" value="2" v-model="displist">
              <label for="d-src2" class="toggle fromimport">Import</label>
            </div>
          </div>
          <div style="flex: 1; display: flex;flex-direction: row-reverse;">
            <!-- Controller -->
            <div class="controller-pane" style="display: inline-block; height: 100%; width: 40px;">
              <input type="button" value="▶" class="control-button" tabindex="-1" @click="insertDataUI"/>
              <input type="button" value="◀" class="control-button" tabindex="-1" @click="removeDataUI" :disabled="!mergedSelected" />
            </div>
            <div style="display: inline-block; height: 100%; flex:1; text-align: center;">
              <!-- Contents -->
              <select multiple style="width: 95%;height: 95%;">
                <option v-for="v in listDisplay" :class="{removed: v.listed, fromtarget: displist == 1 ,fromimport: displist == 2}">
                  {{v.name}}
                </option>
              </select>
            </div>
          </div>
        </div>
        <div style="display: flex;flex-direction: column; width: 49%; height: 100%;" style="border: solid 1px;">
          <!-- MergedPane -->
          <div style="padding: 4px 0 4px 15px; height: 24px;">
            <div style="display: inline-block; height: 100%;">
              <label style="border: solid 1px; margin: 1px; padding: 4px 8px;font-size: smaller;">Merged</label>
            </div>
          </div>
          <div style="flex: 1; display: flex;flex-direction: row-reverse;">
            <!-- Controller -->
            <div class="controller-pane" style="display: inline-block; height: 100%; width: 40px;">
              <input type="button" value="<<" class="control-button" style="rotate: 90deg;padding-top: 3px;" tabindex="-1" @click="" />
              <input type="button" value="<" class="control-button" style="rotate: 90deg;padding-top: 3px;" tabindex="-1" @click="" />
              <input type="button" value=">" class="control-button" style="rotate: 90deg;padding-top: 3px;" tabindex="-1" @click="" />
              <input type="button" value=">>" class="control-button" style="rotate: 90deg;padding-top: 3px;" tabindex="-1" @click="" />
            </div>
            <div style="display: inline-block; height: 100%; flex:1;text-align: center;">
              <!-- Contents -->
              <select multiple style="width: 95%;height: 95%;" v-model="mergedSelectedNames">
                <option :value="i" v-for="(v, i) in editTemp">{{v.data.name+"1"}}</option>
              </select>
            </div>
          </div>
        </div>
      </div>
      <div>
        <input type="button" value="Export" @click="exportJSON" />
        <a style="display: none;" id="downloader" download="edited.physics3.json"></a>
        <p>
          <b>Added Output Parameter</b><br />
          <span v-for="v in addedOutputParams">{{v}}<br /></span>
        </p>
      </div>
    </div>
  </div>
</body>
<script>
  const styles = {
    CRowSwapWarning: ['RowSwapWarning'],
  };
  const DataSource = {
    TARGET: 1,
    IMPORT: 2,
  };
  const app = new Vue({
    el: "#app",
    data: {
      isDebug: false,
      mergedSelectedNames: [],
      displist: DataSource.IMPORT,
      objFileErrors: [],
      srcFileErrors: [],
      befEditErrors: [],
      selectedTargetFile: "",
      selectedImportFile: "",
      canStartEditing: false,
      isEditing: false,
      fcDest: null,
      objFileContent: null,
      fcTemp: null,
      srcFileContent: null,
      listOriginal: [
        {
          idx: 0,
          originalName: "orig0",
          renamedName: null,
        },
      ],
      listImport: [
        {
          idx: 0,
          originalName: "import0",
          renamedName: null,
        },
      ],
      editTempList: [
        {
          DataSource: DataSource.TARGET,
          dataIdx: 0,
        },
      ],
    },
    methods: {
      initEditTemp: function () {
        let arr = this.fcDest.Meta.PhysicsDictionary.map((v, i) => ({
          idx: i,
          originalName: v.Name,
          renamedName: null,
        }));
        fixDuplicateNames(arr);
        this.listOriginal = arr;
        arr = (this.fcTemp?.Meta?.PhysicsDictionary || []).map((v, i) => ({
          idx: i,
          originalName: v.Name,
          renamedName: null,
        }));
        fixDuplicateNames(arr);
        this.listImport = arr;
        this.editTempList = [];
        this.insertData(0, DataSource.TARGET, this.listOriginal.map((v, i) => i));
      },
      insertData: function (insertIdx, DataSource, dataIdxs) {
        this.editTempList.splice(
          insertIdx || insertIdx === 0 ? 0 : this.editTempList.length,
          0,
          ...dataIdxs.map(i => ({
            DataSource: DataSource,
            dataIdx: i,
          }))
        );
      },
      insertDataUI: function () {
        // TODO: Implement
      },
      removeDataUI: function () {
        // TODO: Implement
      },
      swapper(i, j) { // TODO: Convert
        if (i == j) return;
        const temp = (this.editTemp.splice(i, 1, this.editTemp[j]))[0];
        this.editTemp.splice(j, 1, temp);
      },
      chgSortNum: function (i, event, j, name) { // TODO: Convert
        if (i < 0 || this.editTemp.length - 1 < i) return this.restoreFocus(name);;
        if (event) {
          j = event.target.value;
        }
        if (j < 0 || this.editTemp.length - 1 < j) return this.restoreFocus(name);;
        this.swapper(i, j);
        this.restoreFocus(name);
      },
      restoreFocus: function (name) {
        this.$nextTick(() => {
          document.querySelector("[data-key=\"" + name + "\"] [name=editTblSorter]").focus();
        });
      },
      destSwapped: function (idx) {
         // TODO: Convert
        const curDestIndex = this.editTemp[idx].destIndex;
        return (curDestIndex >= 0
          && this.editTemp.slice(0, idx).some(e => e.destIndex >= curDestIndex)
          ? styles.CRowSwapWarning
          : '');
      },
      tempSwapped: function (idx) {
         // TODO: Convert
        const curTmpIndex = this.editTemp[idx].tmpIndex;
        return (curTmpIndex >= 0
          && this.editTemp.slice(0, idx).some(e => e.tmpIndex >= curTmpIndex)
          ? styles.CRowSwapWarning
          : '');
      },
      exportJSON: function () {
        const newFc = this.resultJSON

        const jsonStr = JSON.stringify(newFc, null, 2);
        const blob = new Blob([jsonStr], { type: "application/json;charset=utf-8" });
        const url = URL.createObjectURL(blob);
        const a = document.getElementById("downloader");
        a.href = url;
        a.click();
        URL.revokeObjectURL(url);
      },
      clearSrcFile: function () {
        this.selectedImportFile = "";
        this.srcFileContent = null;
        this.srcFileErrors.splice(0);
        srcFile.value = "";
        checkBeforeEditError();
      },
      editStart: function () {
        if (this.isEditing || !this.canStartEditing) {
          return;
        }
        this.fcDest = JSON.parse(JSON.stringify(this.objFileContent));
        this.fcTemp = this.srcFileContent
          ? JSON.parse(JSON.stringify(this.srcFileContent))
          : null;
        this.isEditing = true;
        this.initEditTemp();
      },
      reselectFiles: function () {
        if ("reselect" != prompt("Your Edits will be lost.\nIf you are sure type \"reselect\" into the following box and push OK.", "deny")) {
          return;
        }
        this.isEditing = false;
      },
    },
    computed: {
      editTemp: function () {
        let arr = this.editTempList;
        return arr.map(v => {
          let obj = JSON.parse(JSON.stringify([,this.listOriginal,this.listImport][v.DataSource][v.dataIdx]));
          obj.name = obj.renamedName || obj.originalName || "";
          obj = {
            DataSource: v.DataSource,
            dataIdx: v.dataIdx,
            data: obj,
          };
          return obj;
        });
      },
      listOriginalTable: function () {
        let arr = this.listOriginal;
        const listedTemp = this.editTempList.filter(v => v.DataSource == DataSource.TARGET).map(v => v.dataIdx);
        return arr.map((v, i) => {
          let obj = JSON.parse(JSON.stringify(v));
          obj.name = v.renamedName || v.originalName || "";
          obj.listed = listedTemp.includes(i);
          return obj;
        });
      },
      listImportTable: function () {
        let arr = this.listImport;
        const listedTemp = this.editTempList.filter(v => v.DataSource == DataSource.IMPORT).map(v => v.dataIdx);
        return arr.map((v, i) => {
          let obj = JSON.parse(JSON.stringify(v));
          obj.name = v.renamedName || v.originalName || "";
          obj.listed = listedTemp.includes(i);
          return obj;
        });
      },
      listDisplay: function () {
        return [,this.listOriginalTable,this.listImportTable][this.displist];
      },
      resultJSON: function () {
        const newFc = JSON.parse(JSON.stringify(this.fcDest));
        const newPhysicsSettings = [];
        const newPhysicsDictionary = [];

        this.editTemp.forEach((v) => {
          const list = [,this.fcDest,this.fcTemp][v.DataSource];
          newPhysicsSettings.push(JSON.parse(JSON.stringify(list.PhysicsSettings[v.dataIdx])));
          const dict = JSON.parse(JSON.stringify(list.Meta.PhysicsDictionary[v.dataIdx]));
          dict.Name = v.data.renamedName || v.data.originalName || "";
          newPhysicsDictionary.push(dict);
        });

        newFc.PhysicsSettings = newPhysicsSettings;
        newFc.Meta.PhysicsDictionary = newPhysicsDictionary;
        newFc.Meta.PhysicsDictionary.forEach((v, i) => {
          const id = "PhysicsSetting" + (i + 1);
          v.Id = id;
          newFc.PhysicsSettings[i].Id = id;
        });
        newFc.Meta.PhysicsSettingCount = newPhysicsSettings.length;
        const counts = newPhysicsSettings.reduce(
          (p, v) => [
            p[0] + v.Input.length,
            p[1] + v.Output.length,
            p[2] + v.Vertices.length
          ], [0, 0, 0]
        );
        newFc.Meta.TotalInputCount = counts[0];
        newFc.Meta.TotalOutputCount = counts[1];
        newFc.Meta.VertexCount = counts[2];
        return newFc;
      },
      destParams: function () {
        const src = this.fcDest;
        if (!src || !src?.PhysicsSettings?.length) return [];
        this.listOriginal.reduce((p, v, i) => {
          return p.concat(
            src.PhysicsSettings[i].Output
              .filter(v2 => v2.Destination.Target == "Parameter").map(v2 => v2.Destination.Id)
          ).concat(
            src.PhysicsSettings[i].Input
              .filter(v2 => v2.Source.Target == "Parameter").map(v2 => v2.Source.Id)
          );
        }, []);
      },
      importOutputParams: function () {
        const src = this.fcTemp;
        if (!src || !src?.PhysicsSettings?.length) return [];
        const list = this.editTempList.filter(v => v.DataSource == DataSource.IMPORT).map(v => v.dataIdx);
        return list.reduce((p, v) => {
          return p.concat(
            src.PhysicsSettings[v].Output
              .filter(v2 => v2.Destination.Target == "Parameter").map(v2 => v2.Destination.Id)
          );
        }, []);
      },
      addedOutputParams: function () {
        return this.importOutputParams.filter(v => !this.destParams.includes(v));
      },
      importInputParams: function () {
        const src = this.fcTemp;
        if (!src || !src?.PhysicsSettings?.length) return [];
        const list = this.editTempList.filter(v => v.DataSource == DataSource.IMPORT).map(v => v.dataIdx);
        return list.reduce((p, v) => {
          return p.concat(
            src.PhysicsSettings[v].Input
              .filter(v2 => v2.Source.Target == "Parameter").map(v2 => v2.Source.Id)
          );
        }, []);
      },
      addedInputParams: function () {
        return this.importInputParams.filter(v => !this.destParams.includes(v));
      },
      mergedSelected: function () {
        return this.mergedSelectedNames.length;
      },
    },
  });

  const objFile = document.getElementById("objFile");
  const srcFile = document.getElementById("srcFile");

  const reader1 = new FileReader();
  reader1.onload = function (e) {
    try {
      let text = e.target.result;
      text = JSON.parse(text);
      app.selectedTargetFile = objFile.files[0].name;
      app.objFileContent = text;
    } catch (err) {
      app.objFileErrors.push("Failed to read file as JSON: " + err.message);
    }
    checkBeforeEditError();
  };
  reader1.onerror = function () {
    app.objFileErrors.push("Failed to read file");
  };
  const reader2 = new FileReader();
  reader2.onload = function (e) {
    try {
      let text = e.target.result;
      text = JSON.parse(text);
      app.selectedImportFile = srcFile.files[0].name;
      app.srcFileContent = text;
    } catch (err) {
      app.srcFileErrors.push("Failed to read file as JSON: " + err.message);
    }
    checkBeforeEditError();
  };
  reader2.onerror = function () {
    app.srcFileErrors.push("Failed to read file");
  };
  function checkBeforeEditError() {
    app.canStartEditing = false;
    app.befEditErrors.splice(0);
    if (!app.objFileContent) {
      app.befEditErrors.push("Target File is Empty.");
    } else if (app.objFileContent.Version != 3) {
      app.befEditErrors.push("Target File’s version is not supported.");
    } else if (!isValidPhysicsJSON(app.objFileContent, "Target")) {
      app.befEditErrors.push("Target File is not valid as .physics3.json");
    }
    if (!app.srcFileContent) {
      // app.befEditErrors.push("Import File is Empty.");
    } else if (app.srcFileContent.Version != 3) {
      app.befEditErrors.push("Import File’s version is not supported.");
    } else if (!isValidPhysicsJSON(app.srcFileContent, "Import")) {
      app.befEditErrors.push("Import File is not valid as .physics3.json");
    }
    app.canStartEditing = app.befEditErrors.length == 0;
  }

  objFile.onchange = function () {
    const file = objFile.files[0];
    app.selectedTargetFile = "";
    app.objFileContent = null;
    app.objFileErrors.splice(0);
    if (!file) {
      app.objFileErrors.push("Target File is Empty");
      checkBeforeEditError();
      return;
    }
    reader1.readAsText(file, "utf-8");
  };
  srcFile.onchange = function () {
    const file = srcFile.files[0];
    app.selectedImportFile = "";
    app.srcFileContent = null;
    app.srcFileErrors.splice(0);
    if (!file) {
      app.srcFileErrors.push("Import File is Empty");
      checkBeforeEditError();
      return;
    }
    reader2.readAsText(file, "utf-8");
  };

  function fixDuplicateNames(obj) {
    while (hasSameNames(obj)) {
      const names = {};
      obj.forEach(v => {
        const name = v.renamedName || v.originalName || "";
        if (!names[name]) {
          names[name] = 0;
        }
        names[name]++;
        if (names[name] > 1) {
          v.renamedName = name + "_" + names[name];
        }
      });
    }
  }

  function hasSameNames(obj) {
    const names = obj.map(v => v.renamedName || v.originalName || "");
    return new Set(names).size !== names.length;
  }

  function isValidPhysicsJSON(obj, name) {
    if (!obj || !obj?.PhysicsSettings?.length || !obj?.Meta?.PhysicsDictionary?.length) {
      app.befEditErrors.push(`${name} File is missing Meta.PhysicsDictionary or PhysicsSettings`);
      return false;
    }
    if (obj.PhysicsSettings.length < obj.Meta.PhysicsDictionary.length) {
      app.befEditErrors.push(`${name} File contains more entries in Meta.PhysicsDictionary than in PhysicsSettings`);
      return false;
    }
    if (obj.Meta.PhysicsDictionary.some((pd, i) => pd.Id !== obj.PhysicsSettings[i].Id)) {
      app.befEditErrors.push(`${name} File has mismatched Ids between Meta.PhysicsDictionary and PhysicsSettings`);
      return false;
    }
    const names = obj.Meta.PhysicsDictionary.map(v => v.Name);
    if (new Set(names).size !== names.length) {
      // TODO: Dupe Name Error will automatically fix later
      app.befEditErrors.push(`${name} File contains duplicate Names in Meta.PhysicsDictionary`);
      return false;
    }
    return true;
  }
</script>

</html>