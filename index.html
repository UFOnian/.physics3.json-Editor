<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Physics JSON Editor</title>
    <script src="https://cdn.jsdelivr.net/npm/vue@2"></script>
</head>
<body>
  <style>
    table,
    th,
    td {
      border: 1px solid black;
      border-collapse: collapse;
    }

    table.no-border,
    table.no-border th,
    table.no-border td {
      border: none;
    }

    th,
    td {
      padding: 5px 10px;
    }
  </style>
  <div id="app">
    <div v-show="!isEditing">
      <!-- File Selector -->
      <table>
        <tr>
          <th>title</th>
          <td>Target File</td>
          <td>Import File</td>
        </tr>
        <tr>
          <th>File Selector</th>
          <td><input type="file" name="objFile" id="objFile" /></td>
          <td>
            <input type="file" name="srcFIle" id="srcFIle" /><br />
            <input type="button" value="clear" @click="clearSrcFile" />
          </td>
        </tr>
        <tr>
          <th>Errors<br />(when exists)</th>
          <td style="color: red;">
            <p v-for="v in objFileErrors">{{v}}</p>
          </td>
          <td style="color: red;">
            <p v-for="v in srcFileErrors">{{v}}</p>
          </td>
        </tr>
      </table>
      <div>
        <p style="color: red;" v-for="v in befEditErrors">{{v}}</p>
        <input type="button" value="Start Editing" @click="editStart" :disabled="!canStartEditing" />
      </div>
    </div>
    <div v-show="isEditing">
      <!-- Source Files Display -->
      <table>
        <tr>
          <th>title</th>
          <td>Target File</td>
          <td>Import File</td>
        </tr>
        <tr>
          <th>File</th>
          <td>{{selectedTargetFile}}</td>
          <td>{{selectedImportFile}}</td>
        </tr>
      </table>
      <div>
        <input type="button" value="Reselect Files" @click="reselectFiles" />
      </div>
    </div>
    <div v-show="isEditing">
      <table>
        <tr>
          <th>Sort</th>
          <th>Physics Dictionary Name</th>
          <th colspan="2">Exists in Target File</th>
          <th colspan="2">Exists in Import File</th>
        </tr>
        <tr v-for="(v,i) in editTemp" :key="v.name" :data-key="v.name">
          <td style="padding: 0;">
            <table class="no-border" style="padding: 0;">
              <tr style="padding: 0;">
                <td style="padding: 5px 0 5px 5px;">
                  <input type="button" value="▲" style="display: block" tabindex="-1" :disabled="!i" @click="swapper(i-1,i)" />
                  <input type="button" value="▼" style="display: block" tabindex="-1" :disabled="!(editTemp.length-i-1)" @click="swapper(i,i+1)" />
                </td>
                <td style="padding: 0 5px 0 2px;">
                  <input type="text" size="1" inputmode="numeric" pattern="\d|[1-9]\d*" name="editTblSorter" class="sortNum" min="0" :max="editTemp.length-1" step="1" :value="i" @keydown.up.prevent="chgSortNum(i, null, i-1,v.name)" @keydown.down.prevent="chgSortNum(i, null, i+1,v.name)"
                    @keydown.subtract.prevent @change.prevent="chgSortNum(i, $event, 0, v.name)">
                </td>
              </tr>
            </table>
          </td>
          <td>{{v.name}}</td>
          <!-- Exists in Target File -->
          <td style="width: 0;" :style="v.destIndex>=0 && editTemp.slice(0,i).some(e=>e.destIndex>=v.destIndex) ? 'background-color: hotpink;' : ''">
            {{v.hasDestData ? v.destIndex : ""}}
          </td>
          <td>
            {{v.hasDestData ? 'YES' : 'No'}}
          </td>
          <!-- Exists in Import File -->
          <td style="width: 0;" :style="v.tmpIndex>=0 && editTemp.slice(0,i).some(e=>e.tmpIndex>=v.tmpIndex) ? 'background-color: hotpink;' : ''">
            {{v.hasTmpData ? v.tmpIndex : ""}}
          </td>
          <td>
            {{v.hasTmpData ? 'YES' : 'No'}}
            <span v-show="v.hasTmpData">
              <input type="checkbox" v-model="v.importData" />Import
            </span>
          </td>
        </tr>
      </table>
      <input type="button" value="Export" @click="exportJSON" />
      <a style="display: none;" id="downloader" download="edited.physics3.json"></a>
      <p>
        <b>Added Output Parameter</b><br />
        <span v-for="v in addedOutputParams">{{v}}<br /></span>
      </p>
    </div>
  </div>
  <script>
    app = new Vue({
      el: "#app",
      data: {
        objFileErrors: [],
        srcFileErrors: [],
        befEditErrors: [],
        selectedTargetFile: "",
        selectedImportFile: "",
        canStartEditing: false,
        isEditing: false,
        fcDest: null,
        objFileContent: null,
        fcTemp: null,
        srcFileContent: null,
        editTemp: [
          {
            name: "physicsDictionaryName",
            hasDestData: false,
            destIndex: -1,
            hasTmpData: false,
            tmpIndex: -1,
            importData: false,
            sortSelect: false,
          },
        ],
      },
      methods: {
        newEditTempRow: function (init) {
          const tmp = {
            name: "physicsDictionaryName",
            hasDestData: false,
            destIndex: -1,
            hasTmpData: false,
            tmpIndex: -1,
            importData: false,
            sortSelect: false,
          };
          Object.keys(tmp).forEach(v => {
            if (init.hasOwnProperty(v)) {
              tmp[v] = init[v];
            }
          });
          return tmp;
        },
        initEditTemp: function () {
          let arr = this.fcDest.Meta.PhysicsDictionary.map((v, i) => this.newEditTempRow({
            name: v.Name,
            hasDestData: true,
            destIndex: i,
          }));
          const tmp = this.fcTemp.Meta.PhysicsDictionary.map((v) => v.Name);
          arr = arr.concat(
            tmp
              .map((v, i) => this.newEditTempRow({
                name: v,
                hasTmpData: true,
                tmpIndex: i,
              }))
              .filter((v) => !arr.some((e) => e.name == v.name))
          );
          arr
            .filter((v) => v.hasDestData && tmp.includes(v.name))
            .forEach((v) => {
              if (!v.hasDestData) return;
              tmp.forEach((e, i) => {
                if (v.hasTmpData) return;
                if (e == v.name) {
                  v.hasTmpData = true;
                  v.tmpIndex = i;
                }
              });
            });
          this.editTemp = arr;
        },
        swapper(i, j) {
          const temp = (this.editTemp.splice(i, 1, this.editTemp[j]))[0];
          this.editTemp.splice(j, 1, temp);
        },
        chgSortNum: function (i, event, j, name) {
          if (i < 0 || this.editTemp.length - 1 < i) return this.restoreFocus(name);;
          if (event) {
            j = event.target.value;
          }
          if (j < 0 || this.editTemp.length - 1 < j) return this.restoreFocus(name);;
          this.swapper(i, j);
          this.$forceUpdate();
          this.restoreFocus(name);
        },
        restoreFocus: function (name) {
          this.$nextTick(() => {
            document.querySelector("[data-key=\"" + name + "\"] [name=editTblSorter]").focus();
          });
        },
        exportJSON: function () {
          const newFc = JSON.parse(JSON.stringify(this.fcDest));
          const newPhysicsSettings = this.editTemp.map((v) => {
            if (v.hasDestData) {
              if (v.importData) {
                return this.fcTemp.PhysicsSettings[v.tmpIndex];
              } else {
                return this.fcDest.PhysicsSettings[v.destIndex];
              }
            } else if (v.importData) {
              return this.fcTemp.PhysicsSettings[v.tmpIndex];
            } else {
              return null;
            }
          }).filter(v => v);
          const newPhysicsDictionary = this.editTemp.map((v) => {
            if (v.hasDestData) {
              if (v.importData) {
                return this.fcTemp.Meta.PhysicsDictionary[v.tmpIndex];
              } else {
                return this.fcDest.Meta.PhysicsDictionary[v.destIndex];
              }
            } else if (v.importData) {
              return this.fcTemp.Meta.PhysicsDictionary[v.tmpIndex];
            } else {
              return null;
            }
          }).filter(v => v);
          newFc.PhysicsSettings = newPhysicsSettings;
          newFc.Meta.PhysicsDictionary = newPhysicsDictionary;
          newFc.Meta.PhysicsDictionary.forEach((v, i) => {
            const id = "PhysicsSetting" + (i + 1);
            v.Id = id;
            newFc.PhysicsSettings[i].Id = id;
          });
          newFc.Meta.PhysicsSettingCount = newPhysicsSettings.length;
          const counts = newPhysicsSettings.reduce(
            (p, v) => [
              p[0] + v.Input.length,
              p[1] + v.Output.length,
              p[2] + v.Vertices.length
            ], [0, 0, 0]
          );
          newFc.Meta.TotalInputCount = counts[0];
          newFc.Meta.TotalOutputCount = counts[1];
          newFc.Meta.VertexCount = counts[2];

          const jsonStr = JSON.stringify(newFc, null, 2);
          const blob = new Blob([jsonStr], { type: "application/json;charset=utf-8" });
          const url = URL.createObjectURL(blob);
          const a = document.getElementById("downloader");
          a.href = url;
          a.click();
          URL.revokeObjectURL(url);
        },
        clearSrcFile: function () {
          this.selectedImportFile = "";
          this.srcFileContent = null;
          this.srcFileErrors.splice(0);
          srcFIle.value = "";
          checkBeforeEditError();
        },
        editStart: function () {
          if (this.isEditing || !this.canStartEditing) {
            return;
          }
          this.fcDest = JSON.parse(JSON.stringify(this.objFileContent));
          this.fcTemp = this.srcFileContent
            ? JSON.parse(JSON.stringify(this.srcFileContent))
            : null;
          this.isEditing = true;
          this.initEditTemp();
        },
        reselectFiles: function () {
          if ("reselect" != prompt("Your Edits will be lost.\nIf you are sure type \"reselect\" into the following box and push OK.", "deny")) {
            return;
          }
          this.isEditing = false;
        },
      },
      computed: {
        destOutputParams: function () {
          const src = this.fcDest;
          if (!src) return [];
          if (!src || !src?.PhysicsSettings?.length) return [];
          return src.PhysicsSettings.reduce(
            (p1, v1) => p1.concat(
              v1.Output.filter(v2 => v2.Destination.Target == "Parameter").map(v2 => v2.Destination.Id)
            )
            , []);
        },
        importOutputParams: function () {
          if (!this.fcTemp) return [];
          return this.editTemp.filter(v => v.importData).reduce(
            (p1, v1) => p1.concat(
              this.fcTemp.PhysicsSettings[v1.tmpIndex].Output
                .filter(v2 => v2.Destination.Target == "Parameter").map(v2 => v2.Destination.Id)
            )
            , []);
        },
        addedOutputParams: function () {
          if (!this.fcTemp) return [];
          if (!this.importOutputParams.length) return [];
          return this.importOutputParams.filter(v => !this.destOutputParams.includes(v));
        },
      },
    });

    const objFile = document.getElementById("objFile");
    const srcFile = document.getElementById("srcFIle");

    const reader1 = new FileReader();
    reader1.onload = function (e) {
      try {
        let text = e.target.result;
        text = JSON.parse(text);
        app.selectedTargetFile = objFile.files[0].name;
        app.objFileContent = text;
      } catch (err) {
        app.objFileErrors.push("Failed to read file as JSON: " + err.message);
      }
      checkBeforeEditError();
    };
    reader1.onerror = function () {
      app.objFileErrors.push("Failed to read file");
    };
    const reader2 = new FileReader();
    reader2.onload = function (e) {
      try {
        let text = e.target.result;
        text = JSON.parse(text);
        app.selectedImportFile = srcFile.files[0].name;
        app.srcFileContent = text;
      } catch (err) {
        app.srcFileErrors.push("Failed to read file as JSON: " + err.message);
      }
      checkBeforeEditError();
    };
    reader2.onerror = function () {
      app.srcFileErrors.push("Failed to read file");
    };
    function checkBeforeEditError() {
      app.canStartEditing = false;
      app.befEditErrors.splice(0);
      if (!app.objFileContent) {
        app.befEditErrors.push("Target File is Empty.");
      } else if (app.objFileContent.Version != 3) {
        app.befEditErrors.push("Target File’s version is not supported.");
      } else if (!isValidPhysicsJSON(app.objFileContent)) {
        app.befEditErrors.push("Target File is not valid as .physics3.json");
      }
      if (!app.srcFileContent) {
        // app.befEditErrors.push("Import File is Empty.");
      } else if (app.srcFileContent.Version != 3) {
        app.befEditErrors.push("Import File’s version is not supported.");
      } else if (!isValidPhysicsJSON(app.srcFileContent)) {
        app.befEditErrors.push("Import File is not valid as .physics3.json");
      }
      app.canStartEditing = app.befEditErrors.length == 0;
    }

    objFile.onchange = function () {
      const file = objFile.files[0];
      app.selectedTargetFile = "";
      app.objFileContent = null;
      app.objFileErrors.splice(0);
      if (!file) {
        app.objFileErrors.push("Target File is Empty");
        checkBeforeEditError();
        return;
      }
      reader1.readAsText(file, "utf-8");
    };
    srcFile.onchange = function () {
      const file = srcFile.files[0];
      app.selectedImportFile = "";
      app.srcFileContent = null;
      app.srcFileErrors.splice(0);
      if (!file) {
        app.srcFileErrors.push("Import File is Empty");
        checkBeforeEditError();
        return;
      }
      reader2.readAsText(file, "utf-8");
    };

    function isValidPhysicsJSON(obj) {
      return (obj
        && obj?.PhysicsSettings?.length
        && obj?.Meta?.PhysicsDictionary?.length);
    }

  </script>
</body>

</html>
